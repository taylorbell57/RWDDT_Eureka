name: Publish Docker Image on Tag

on:
  push:
    tags:
      - 'v*'
      - '[0-9]+.[0-9]+*'   # allow tags without a leading 'v'

jobs:
  docker-build-and-push:
    # Block prereleases (e.g., v1.2.3-rc.1) and build-metadata (e.g., v1.2.3+abc)
    if: ${{ !contains(github.ref_name, '-') && !contains(github.ref_name, '+') }}
    runs-on: ubuntu-latest

    steps:
      - name: Check out the code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Compute tag set (strip v, decide 0 and latest)
        id: ver
        shell: bash
        run: |
          set -euo pipefail

          REPO="${{ secrets.DOCKERHUB_USERNAME }}/rwddt_eureka"

          RAW="${GITHUB_REF_NAME}"              # e.g., v0.5, 0.5.1
          VER="${RAW#v}"                        # strip leading v if present

          # Only allow X.Y or X.Y.Z (numeric) – prereleases were blocked at job level
          if [[ ! "$VER" =~ ^([0-9]+)\.([0-9]+)(\.([0-9]+))?$ ]]; then
            echo "Unsupported tag format: $RAW"
            exit 1
          fi
          MAJ="${BASH_REMATCH[1]}"
          MIN="${BASH_REMATCH[2]}"
          # Group 3 is ".PATCH"; group 4 is just PATCH digits
          PAT="${BASH_REMATCH[4]:-}"           # empty if two-part

          # Normalize to X.Y.Z for comparisons
          if [ -z "$PAT" ]; then
            CUR_NORM="${MAJ}.${MIN}.0"
          else
            CUR_NORM="${MAJ}.${MIN}.${PAT}"
          fi

          # Collect repo tags that are strictly numeric X.Y or X.Y.Z (ignore prereleases/build metadata)
          mapfile -t ALL_NORM < <(
            git tag -l --sort=refname \
              | grep -E '^(v)?[0-9]+\.[0-9]+(\.[0-9]+)?$' \
              | sed 's/^v//' \
              | awk -F. '{
                  if (NF==2) printf "%s.%s.0\n", $1,$2;
                  else if (NF==3) printf "%s.%s.%s\n", $1,$2,$3;
                }' \
              | sort -V
          )

          # Highest overall X.Y.Z
          HIGHEST_OVERALL="$(printf "%s\n" "${ALL_NORM[@]}" | tail -n1 || true)"

          # Highest minor for this major (X.Y)
          mapfile -t MAJ_MINORS < <(printf "%s\n" "${ALL_NORM[@]}" \
            | awk -F. -v M="$MAJ" '$1==M { printf "%s.%s\n", $1,$2 }' \
            | sort -V | uniq)
          HIGHEST_MINOR_FOR_MAJOR="$(printf "%s\n" "${MAJ_MINORS[@]}" | tail -n1 || true)"

          # Highest patch for this minor (X.Y.Z)
          mapfile -t MIN_PATCHES < <(printf "%s\n" "${ALL_NORM[@]}" \
            | awk -F. -v M="$MAJ" -v N="$MIN" '$1==M && $2==N { printf "%s.%s.%s\n", $1,$2,$3 }' \
            | sort -V)
          HIGHEST_PATCH_FOR_MINOR="$(printf "%s\n" "${MIN_PATCHES[@]}" | tail -n1 || true)"

          # Build desired docker tags (always without 'v')
          TAGS=()

          if [ -z "$PAT" ]; then
            # Two-part Git tag → push MAJOR.MINOR
            TAGS+=("${REPO}:${MAJ}.${MIN}")
          else
            # Three-part → push MAJOR.MINOR.PATCH
            TAGS+=("${REPO}:${MAJ}.${MIN}.${PAT}")
            # Also MAJOR.MINOR iff highest patch for that minor
            if [ "${CUR_NORM}" = "${HIGHEST_PATCH_FOR_MINOR}" ]; then
              TAGS+=("${REPO}:${MAJ}.${MIN}")
            fi
          fi

          # MAJOR iff this minor is the highest for the major
          if [ -n "${HIGHEST_MINOR_FOR_MAJOR}" ] && [ "${MAJ}.${MIN}" = "${HIGHEST_MINOR_FOR_MAJOR}" ]; then
            TAGS+=("${REPO}:${MAJ}")
          fi

          # latest iff highest overall
          if [ -n "${HIGHEST_OVERALL}" ] && [ "${CUR_NORM}" = "${HIGHEST_OVERALL}" ]; then
            TAGS+=("${REPO}:latest")
          fi

          # De-dupe and export
          printf "%s\n" "${TAGS[@]}" | sort -u > /tmp/tags.txt
          echo "Computed tags:"
          cat /tmp/tags.txt
          {
            echo "list<<EOF"
            cat /tmp/tags.txt
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push (single build, multiple tags)
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.ver.outputs.list }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
